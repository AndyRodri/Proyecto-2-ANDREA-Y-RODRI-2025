#include <Arduino.h>
#include <LiquidCrystal.h>
#include "driver/i2c.h"
#include "driver/spi_slave.h"
#include "esp_heap_caps.h"

/* ================================================================
 *                    CONFIGURACIÓN DE HARDWARE
 * ================================================================ */

// ---------- Pines para I2C ----------
#define I2C_SLAVE_SDA 21            // Pin SDA del ESP32
#define I2C_SLAVE_SCL 22            // Pin SCL del ESP32
#define I2C_SLAVE_NUM I2C_NUM_0     // Puerto I2C a usar (I2C0)
#define I2C_SLAVE_ADDR 0x42         // Dirección I2C del ESP32 (coincide con la del STM32)

// ---------- Pines para SPI ----------
#define SPI_MOSI 23
#define SPI_MISO 19
#define SPI_SCLK 18
#define SPI_CS   5
#define SPI_HOST_VSPI VSPI_HOST     // Bus SPI a utilizar

// ---------- Configuración LCD ----------
LiquidCrystal lcd(32, 33, 4, 16, 17, 15);  // LCD paralelo (pines RS, EN, D4, D5, D6, D7)

// ---------- LEDs ----------
const int ledPins[3] = {25, 26, 27};       // Pines conectados a LEDs
String ultimoLED = "NA";                   // Último LED encendido

// ---------- Potenciómetro ----------
const int potPin = 34;                     // Entrada analógica del potenciómetro

/* ================================================================
 *                 INICIALIZACIÓN DEL MÓDULO SPI (ESCLAVO)
 * ================================================================ */
static void spi_slave_init() {
  spi_bus_config_t buscfg = {};
  buscfg.mosi_io_num = SPI_MOSI;
  buscfg.miso_io_num = SPI_MISO;
  buscfg.sclk_io_num = SPI_SCLK;
  buscfg.quadwp_io_num = -1;   // Pines no usados
  buscfg.quadhd_io_num = -1;

  spi_slave_interface_config_t slvcfg = {};
  slvcfg.spics_io_num = SPI_CS;   // Pin CS controlado por el STM32
  slvcfg.flags = 0;
  slvcfg.queue_size = 3;          // Máximo de transacciones en cola
  slvcfg.mode = 0;                // Modo SPI (CPOL=0, CPHA=0)

  // Inicializar el bus SPI en modo esclavo
  esp_err_t ret = spi_slave_initialize(SPI_HOST_VSPI, &buscfg, &slvcfg, SPI_DMA_CH_AUTO);
  if (ret == ESP_OK)
    Serial.println("SPI slave init OK");
  else
    Serial.printf("SPI slave init error: %d\n", ret);
}

/* ================================================================
 *                 INICIALIZACIÓN DEL MÓDULO I2C (ESCLAVO)
 * ================================================================ */
static void i2c_slave_init() {
  i2c_config_t conf_slave = {};
  conf_slave.mode = I2C_MODE_SLAVE;
  conf_slave.sda_io_num = I2C_SLAVE_SDA;
  conf_slave.scl_io_num = I2C_SLAVE_SCL;
  conf_slave.sda_pullup_en = GPIO_PULLUP_ENABLE;
  conf_slave.scl_pullup_en = GPIO_PULLUP_ENABLE;
  conf_slave.slave.slave_addr = I2C_SLAVE_ADDR;
  conf_slave.slave.addr_10bit_en = 0;  // Dirección de 7 bits

  i2c_param_config(I2C_SLAVE_NUM, &conf_slave);
  i2c_driver_install(I2C_SLAVE_NUM, conf_slave.mode, 128, 128, 0);

  Serial.println("I2C slave init OK");
}

/* ================================================================
 *                   PROCESAR COMANDO SPI (CONTROL DE LEDS)
 * ================================================================ */
static void process_led_command(uint8_t cmd) {
  // Apagar todos los LEDs primero
  for (int i = 0; i < 3; i++)
    digitalWrite(ledPins[i], LOW);

  // Encender el LED correspondiente
  if (cmd >= 1 && cmd <= 3) {
    int idx = cmd - 1;
    digitalWrite(ledPins[idx], HIGH);
    ultimoLED = String(cmd);
    Serial.printf("LED %d ON\n", cmd);
  } else {
    ultimoLED = "NA";
    Serial.printf("Invalid LED cmd: %d\n", cmd);
  }
}

/* ================================================================
 *                     TAREA SPI (HILO INDEPENDIENTE)
 * ================================================================
 * Esta tarea corre en segundo plano.
 * - Espera datos enviados desde el STM32 (modo esclavo SPI)
 * - Cada byte recibido representa el número de LED a encender.
 * ================================================================ */
static void spi_task(void *arg) {
  // Buffer DMA-capable (alineado a 4 bytes)
  static uint8_t rxdata[4] _attribute_((aligned(4)));

  spi_slave_transaction_t t;
  memset(&t, 0, sizeof(t));
  t.length = 8;              // 8 bits (1 byte)
  t.tx_buffer = NULL;        // No se envía respuesta
  t.rx_buffer = rxdata;      // Donde se guarda el byte recibido

  while (true) {
    memset(rxdata, 0, sizeof(rxdata));

    // Esperar transacción desde el maestro (STM32)
    esp_err_t ret = spi_slave_transmit(SPI_HOST_VSPI, &t, portMAX_DELAY);

    if (ret == ESP_OK) {
      uint8_t cmd = rxdata[0];
      if (cmd != 0) {
        Serial.printf("SPI RX: %d\n", cmd);
        process_led_command(cmd);
      }
    } else {
      Serial.printf("SPI error: %d\n", ret);
      vTaskDelay(pdMS_TO_TICKS(500));
    }

    vTaskDelay(pdMS_TO_TICKS(20)); // Pequeña espera antes de la siguiente iteración
  }
}

/* ================================================================
 *                           SETUP
 * ================================================================ */
void setup() {
  Serial.begin(115200);
  delay(500);
  Serial.println("\nESP32 start");

  /* ---------- Configurar LEDs ---------- */
  for (int i = 0; i < 3; i++) {
    pinMode(ledPins[i], OUTPUT);
    digitalWrite(ledPins[i], LOW);
  }

  /* ---------- Configurar LCD ---------- */
  lcd.begin(16, 2);
  lcd.clear();
  lcd.print("ESP32 Ready");

  /* ---------- Inicializar SPI e I2C ---------- */
  spi_slave_init();
  i2c_slave_init();

  /* ---------- Crear tarea SPI ---------- */
  xTaskCreate(spi_task, "spi_task", 4096, NULL, 10, NULL);
}

/* ================================================================
 *                            LOOP PRINCIPAL
 * ================================================================
 * Se ejecuta constantemente y:
 * 1. Lee el valor del potenciómetro.
 * 2. Lo envía al STM32 por I2C (2 bytes).
 * 3. Actualiza el LCD con voltaje, bits y LED activo.
 * ================================================================ */
void loop() {
  /* ---------- Lectura del potenciómetro ---------- */
  int val = analogRead(potPin);                    // 0 - 4095
  float voltage = (val / 4095.0f) * 3.3f;          // Conversión a voltios

  /* ---------- Enviar lectura al STM32 (I2C) ---------- */
  uint8_t data[2];
  data[0] = (uint8_t)(val >> 8);                   // Parte alta
  data[1] = (uint8_t)(val & 0xFF);                 // Parte baja
  i2c_slave_write_buffer(I2C_SLAVE_NUM, data, 2, 100 / portTICK_PERIOD_MS);

  /* ---------- Actualizar LCD ---------- */
  lcd.setCursor(0, 0);
  lcd.print("V:");
  lcd.setCursor(2, 0);
  lcd.print(String(voltage, 2) + "V   ");

  lcd.setCursor(0, 1);
  lcd.print("Bits:");
  lcd.setCursor(6, 1);
  lcd.print(val);
  lcd.print("   ");

  lcd.setCursor(12, 0);
  lcd.print("LED:");
  lcd.setCursor(12, 1);
  lcd.print(ultimoLED + " ");

  delay(200);  // Refresco de la pantalla
}
