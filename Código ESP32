#include "main.h"
#include <stdio.h>
#include <string.h>

/* =================== DEFINICIÓN DE CONSTANTES =================== */
#define I2C_DEV_ADDR 0x42          // Dirección I2C del dispositivo esclavo (ESP32)
#define CS_GPIO_Port GPIOB          // Puerto del pin Chip Select para SPI
#define CS_Pin GPIO_PIN_6           // Pin de Chip Select

/* =================== DECLARACIÓN DE HANDLERS ==================== */
I2C_HandleTypeDef hi2c1;           // Manejador del bus I2C
SPI_HandleTypeDef hspi1;           // Manejador del bus SPI
UART_HandleTypeDef huart2;         // Manejador del puerto UART (comunicación con PC)

/* =================== VARIABLES GLOBALES ========================= */
char uartBuffer[64];               // Buffer para mensajes UART
uint8_t potData[2];                // Datos recibidos desde el ESP32 por I2C (2 bytes)

/* =================== PROTOTIPOS DE FUNCIONES ==================== */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_SPI1_Init(void);
static void MX_I2C1_Init(void);
void MenuPrincipal(void);
void OpcionSPI(void);
void OpcionI2C(void);
void Error_Handler(void);

/* ================================================================
 *                         FUNCIÓN PRINCIPAL
 * ================================================================ */
int main(void)
{
  /* Inicialización básica del microcontrolador */
  HAL_Init();                      // Inicializa la HAL (Hardware Abstraction Layer)
  SystemClock_Config();            // Configura el reloj del sistema
  MX_GPIO_Init();                  // Inicializa los pines GPIO
  MX_USART2_UART_Init();           // Inicializa la comunicación UART
  MX_SPI1_Init();                  // Inicializa la comunicación SPI
  MX_I2C1_Init();                  // Inicializa la comunicación I2C

  /* Mensaje inicial en el monitor serial */
  const char *msg =
      "\r\n** Proyecto 2: Comunicacion Serial ***\r\n"
      "Nucleo listo. Seleccione una opcion.\r\n";
  HAL_UART_Transmit(&huart2, (uint8_t *)msg, strlen(msg), HAL_MAX_DELAY);

  /* Bucle principal */
  while (1)
  {
    MenuPrincipal();               // Muestra el menú principal continuamente
  }
}

/* ================================================================
 *                      MENÚ PRINCIPAL POR UART
 * ================================================================ */
void MenuPrincipal(void)
{
  uint8_t opcion = 0;

  const char *menu =
      "\r\n===== MENU PRINCIPAL =====\r\n"
      "1. Controlar LEDs (SPI)\r\n"
      "2. Leer Potenciometro (I2C)\r\n"
      "Seleccione una opcion: ";

  /* Enviar el menú al monitor serial */
  HAL_UART_Transmit(&huart2, (uint8_t *)menu, strlen(menu), HAL_MAX_DELAY);

  /* Esperar la entrada del usuario */
  while (1)
  {
    HAL_UART_Receive(&huart2, &opcion, 1, HAL_MAX_DELAY);

    /* Ignorar saltos de línea (Enter) */
    if (opcion == '\r' || opcion == '\n')
      continue;

    /* Eco de la tecla presionada */
    HAL_UART_Transmit(&huart2, &opcion, 1, HAL_MAX_DELAY);
    HAL_UART_Transmit(&huart2, (uint8_t *)"\r\n", 2, HAL_MAX_DELAY);

    /* Selección de opción */
    if (opcion == '1')
    {
      OpcionSPI();                 // Control de LEDs
      break;
    }
    else if (opcion == '2')
    {
      OpcionI2C();                 // Lectura de potenciómetro
      break;
    }
    else
    {
      /* Mensaje de advertencia */
      const char *warn = "\r\nOpcion invalida. Intente de nuevo.\r\n";
      HAL_UART_Transmit(&huart2, (uint8_t *)warn, strlen(warn), HAL_MAX_DELAY);
    }
  }
}

/* ================================================================
 *                     OPCIÓN 1: COMUNICACIÓN SPI
 * ================================================================ */
void OpcionSPI(void)
{
  const char *prompt = "\r\nIngrese numero de LED (1, 2 o 3): ";
  HAL_UART_Transmit(&huart2, (uint8_t *)prompt, strlen(prompt), HAL_MAX_DELAY);

  uint8_t led_char = 0;
  uint8_t spiPacket[1];

  while (1)
  {
    HAL_UART_Receive(&huart2, &led_char, 1, HAL_MAX_DELAY);

    if (led_char == '\r' || led_char == '\n')
      continue; // Ignorar Enter

    /* Eco en la terminal */
    HAL_UART_Transmit(&huart2, &led_char, 1, HAL_MAX_DELAY);
    HAL_UART_Transmit(&huart2, (uint8_t *)"\r\n", 2, HAL_MAX_DELAY);

    /* Validar entrada (1-3) */
    if (led_char >= '1' && led_char <= '3')
    {
      uint8_t led_num = (uint8_t)(led_char - '0'); // Conversión ASCII → número
      spiPacket[0] = led_num;

      /* Enviar byte por SPI al ESP32 */
      HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_RESET); // CS = 0
      HAL_SPI_Transmit(&hspi1, spiPacket, 1, HAL_MAX_DELAY);   // Transmisión
      HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_SET);   // CS = 1

      sprintf(uartBuffer, "\r\nComando SPI enviado: LED %d\r\n", led_num);
      HAL_UART_Transmit(&huart2, (uint8_t *)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
      break;
    }
    else
    {
      const char *err = "Valor invalido. Ingrese 1, 2 o 3: ";
      HAL_UART_Transmit(&huart2, (uint8_t *)err, strlen(err), HAL_MAX_DELAY);
    }
  }
}

/* ================================================================
 *                    OPCIÓN 2: COMUNICACIÓN I2C
 * ================================================================ */
void OpcionI2C(void)
{
  /* Recibir 2 bytes desde el dispositivo I2C (ESP32) */
  HAL_StatusTypeDef ret =
      HAL_I2C_Master_Receive(&hi2c1, (I2C_DEV_ADDR << 1), potData, 2, HAL_MAX_DELAY);

  /* Si la comunicación fue exitosa */
  if (ret == HAL_OK)
  {
    uint16_t potValue = ((uint16_t)potData[0] << 8) | potData[1]; // Combinar bytes
    uint32_t mv = (3300UL * potValue) / 4095UL;                   // Conversión a milivoltios

    sprintf(uartBuffer, "\r\nLectura Pot: %u bits (%lu mV)\r\n",
            potValue, (unsigned long)mv);
  }
  else
  {
    sprintf(uartBuffer, "\r\nError de comunicacion I2C\r\n");
  }

  /* Mostrar resultado en UART */
  HAL_UART_Transmit(&huart2, (uint8_t *)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
}

/* ================================================================
 *              CONFIGURACIÓN DE PERIFÉRICOS (MX_*)
 * ================================================================ */

/* ---------- I2C1 ---------- */
static void MX_I2C1_Init(void)
{
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;               // Velocidad estándar: 100 kHz
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;

  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
    Error_Handler();
}

/* ---------- SPI1 ---------- */
static void MX_SPI1_Init(void)
{
  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;            // Modo maestro
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;  // Doble línea: MOSI/MISO
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;      // 8 bits por transferencia
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;    // Reloj en bajo cuando inactivo
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;        // Muestra en primer flanco
  hspi1.Init.NSS = SPI_NSS_SOFT;                // NSS controlado por software
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_32; // Frecuencia de SPI
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;       // Enviar bit más significativo primero
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;

  if (HAL_SPI_Init(&hspi1) != HAL_OK)
    Error_Handler();
}

/* ---------- UART2 ---------- */
static void MX_USART2_UART_Init(void)
{
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;                // Velocidad de comunicación
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;

  if (HAL_UART_Init(&huart2) != HAL_OK)
    Error_Handler();
}

/* ---------- GPIO ---------- */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  __HAL_RCC_GPIOB_CLK_ENABLE();                // Habilitar reloj del puerto B

  /* Configurar pin CS como salida */
  HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_SET);
  GPIO_InitStruct.Pin = CS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(CS_GPIO_Port, &GPIO_InitStruct);
}

/* ================================================================
 *                   CONFIGURACIÓN DEL SISTEMA DE RELOJ
 * ================================================================ */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);

  /* Configurar el oscilador HSI (interno) y el PLL */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 16;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  /* Configurar los buses AHB, APB1, APB2 */
  RCC_ClkInitStruct.ClockType =
      RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
}

/* ================================================================
 *                   MANEJO DE ERRORES
 * ================================================================ */
void Error_Handler(void)
{
  __disable_irq();
  while (1)
  {
    // Bucle infinito para indicar error
  }
}
#include "main.h"
#include <stdio.h>
#include <string.h>

/* =================== DEFINICIÓN DE CONSTANTES =================== */
#define I2C_DEV_ADDR 0x42          // Dirección I2C del dispositivo esclavo (ESP32)
#define CS_GPIO_Port GPIOB          // Puerto del pin Chip Select para SPI
#define CS_Pin GPIO_PIN_6           // Pin de Chip Select

/* =================== DECLARACIÓN DE HANDLERS ==================== */
I2C_HandleTypeDef hi2c1;           // Manejador del bus I2C
SPI_HandleTypeDef hspi1;           // Manejador del bus SPI
UART_HandleTypeDef huart2;         // Manejador del puerto UART (comunicación con PC)

/* =================== VARIABLES GLOBALES ========================= */
char uartBuffer[64];               // Buffer para mensajes UART
uint8_t potData[2];                // Datos recibidos desde el ESP32 por I2C (2 bytes)

/* =================== PROTOTIPOS DE FUNCIONES ==================== */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_SPI1_Init(void);
static void MX_I2C1_Init(void);
void MenuPrincipal(void);
void OpcionSPI(void);
void OpcionI2C(void);
void Error_Handler(void);

/* ================================================================
 *                         FUNCIÓN PRINCIPAL
 * ================================================================ */
int main(void)
{
  /* Inicialización básica del microcontrolador */
  HAL_Init();                      // Inicializa la HAL (Hardware Abstraction Layer)
  SystemClock_Config();            // Configura el reloj del sistema
  MX_GPIO_Init();                  // Inicializa los pines GPIO
  MX_USART2_UART_Init();           // Inicializa la comunicación UART
  MX_SPI1_Init();                  // Inicializa la comunicación SPI
  MX_I2C1_Init();                  // Inicializa la comunicación I2C

  /* Mensaje inicial en el monitor serial */
  const char *msg =
      "\r\n** Proyecto 2: Comunicacion Serial ***\r\n"
      "Nucleo listo. Seleccione una opcion.\r\n";
  HAL_UART_Transmit(&huart2, (uint8_t *)msg, strlen(msg), HAL_MAX_DELAY);

  /* Bucle principal */
  while (1)
  {
    MenuPrincipal();               // Muestra el menú principal continuamente
  }
}

/* ================================================================
 *                      MENÚ PRINCIPAL POR UART
 * ================================================================ */
void MenuPrincipal(void)
{
  uint8_t opcion = 0;

  const char *menu =
      "\r\n===== MENU PRINCIPAL =====\r\n"
      "1. Controlar LEDs (SPI)\r\n"
      "2. Leer Potenciometro (I2C)\r\n"
      "Seleccione una opcion: ";

  /* Enviar el menú al monitor serial */
  HAL_UART_Transmit(&huart2, (uint8_t *)menu, strlen(menu), HAL_MAX_DELAY);

  /* Esperar la entrada del usuario */
  while (1)
  {
    HAL_UART_Receive(&huart2, &opcion, 1, HAL_MAX_DELAY);

    /* Ignorar saltos de línea (Enter) */
    if (opcion == '\r' || opcion == '\n')
      continue;

    /* Eco de la tecla presionada */
    HAL_UART_Transmit(&huart2, &opcion, 1, HAL_MAX_DELAY);
    HAL_UART_Transmit(&huart2, (uint8_t *)"\r\n", 2, HAL_MAX_DELAY);

    /* Selección de opción */
    if (opcion == '1')
    {
      OpcionSPI();                 // Control de LEDs
      break;
    }
    else if (opcion == '2')
    {
      OpcionI2C();                 // Lectura de potenciómetro
      break;
    }
    else
    {
      /* Mensaje de advertencia */
      const char *warn = "\r\nOpcion invalida. Intente de nuevo.\r\n";
      HAL_UART_Transmit(&huart2, (uint8_t *)warn, strlen(warn), HAL_MAX_DELAY);
    }
  }
}

/* ================================================================
 *                     OPCIÓN 1: COMUNICACIÓN SPI
 * ================================================================ */
void OpcionSPI(void)
{
  const char *prompt = "\r\nIngrese numero de LED (1, 2 o 3): ";
  HAL_UART_Transmit(&huart2, (uint8_t *)prompt, strlen(prompt), HAL_MAX_DELAY);

  uint8_t led_char = 0;
  uint8_t spiPacket[1];

  while (1)
  {
    HAL_UART_Receive(&huart2, &led_char, 1, HAL_MAX_DELAY);

    if (led_char == '\r' || led_char == '\n')
      continue; // Ignorar Enter

    /* Eco en la terminal */
    HAL_UART_Transmit(&huart2, &led_char, 1, HAL_MAX_DELAY);
    HAL_UART_Transmit(&huart2, (uint8_t *)"\r\n", 2, HAL_MAX_DELAY);

    /* Validar entrada (1-3) */
    if (led_char >= '1' && led_char <= '3')
    {
      uint8_t led_num = (uint8_t)(led_char - '0'); // Conversión ASCII → número
      spiPacket[0] = led_num;

      /* Enviar byte por SPI al ESP32 */
      HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_RESET); // CS = 0
      HAL_SPI_Transmit(&hspi1, spiPacket, 1, HAL_MAX_DELAY);   // Transmisión
      HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_SET);   // CS = 1

      sprintf(uartBuffer, "\r\nComando SPI enviado: LED %d\r\n", led_num);
      HAL_UART_Transmit(&huart2, (uint8_t *)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
      break;
    }
    else
    {
      const char *err = "Valor invalido. Ingrese 1, 2 o 3: ";
      HAL_UART_Transmit(&huart2, (uint8_t *)err, strlen(err), HAL_MAX_DELAY);
    }
  }
}

/* ================================================================
 *                    OPCIÓN 2: COMUNICACIÓN I2C
 * ================================================================ */
void OpcionI2C(void)
{
  /* Recibir 2 bytes desde el dispositivo I2C (ESP32) */
  HAL_StatusTypeDef ret =
      HAL_I2C_Master_Receive(&hi2c1, (I2C_DEV_ADDR << 1), potData, 2, HAL_MAX_DELAY);

  /* Si la comunicación fue exitosa */
  if (ret == HAL_OK)
  {
    uint16_t potValue = ((uint16_t)potData[0] << 8) | potData[1]; // Combinar bytes
    uint32_t mv = (3300UL * potValue) / 4095UL;                   // Conversión a milivoltios

    sprintf(uartBuffer, "\r\nLectura Pot: %u bits (%lu mV)\r\n",
            potValue, (unsigned long)mv);
  }
  else
  {
    sprintf(uartBuffer, "\r\nError de comunicacion I2C\r\n");
  }

  /* Mostrar resultado en UART */
  HAL_UART_Transmit(&huart2, (uint8_t *)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
}

/* ================================================================
 *              CONFIGURACIÓN DE PERIFÉRICOS (MX_*)
 * ================================================================ */

/* ---------- I2C1 ---------- */
static void MX_I2C1_Init(void)
{
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;               // Velocidad estándar: 100 kHz
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;

  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
    Error_Handler();
}

/* ---------- SPI1 ---------- */
static void MX_SPI1_Init(void)
{
  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;            // Modo maestro
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;  // Doble línea: MOSI/MISO
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;      // 8 bits por transferencia
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;    // Reloj en bajo cuando inactivo
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;        // Muestra en primer flanco
  hspi1.Init.NSS = SPI_NSS_SOFT;                // NSS controlado por software
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_32; // Frecuencia de SPI
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;       // Enviar bit más significativo primero
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;

  if (HAL_SPI_Init(&hspi1) != HAL_OK)
    Error_Handler();
}

/* ---------- UART2 ---------- */
static void MX_USART2_UART_Init(void)
{
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;                // Velocidad de comunicación
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;

  if (HAL_UART_Init(&huart2) != HAL_OK)
    Error_Handler();
}

/* ---------- GPIO ---------- */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  __HAL_RCC_GPIOB_CLK_ENABLE();                // Habilitar reloj del puerto B

  /* Configurar pin CS como salida */
  HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_SET);
  GPIO_InitStruct.Pin = CS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(CS_GPIO_Port, &GPIO_InitStruct);
}

/* ================================================================
 *                   CONFIGURACIÓN DEL SISTEMA DE RELOJ
 * ================================================================ */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);

  /* Configurar el oscilador HSI (interno) y el PLL */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 16;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  /* Configurar los buses AHB, APB1, APB2 */
  RCC_ClkInitStruct.ClockType =
      RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
}

/* ================================================================
 *                   MANEJO DE ERRORES
 * ================================================================ */
void Error_Handler(void)
{
  __disable_irq();
  while (1)
  {
    // Bucle infinito para indicar error
  }
}

